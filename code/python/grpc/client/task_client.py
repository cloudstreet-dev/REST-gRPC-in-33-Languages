import asyncio
from typing import List, Optional, Dict, Any
import grpc

# Import generated proto files (these will be generated by the script)
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# These imports assume proto files have been generated
# import tasks_pb2
# import tasks_pb2_grpc


class TaskGrpcClient:
    """gRPC client for Task Management Service"""
    
    def __init__(self, host: str = "localhost:50051"):
        self.host = host
        self.channel = None
        self.stub = None
    
    async def __aenter__(self):
        await self.connect()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()
    
    async def connect(self):
        """Establish connection to gRPC server"""
        self.channel = grpc.aio.insecure_channel(self.host)
        # self.stub = tasks_pb2_grpc.TaskServiceStub(self.channel)
    
    async def close(self):
        """Close the gRPC channel"""
        if self.channel:
            await self.channel.close()
    
    async def list_tasks(
        self,
        page_size: int = 20,
        page_token: Optional[str] = None,
        status: Optional[str] = None,
        assigned_to: Optional[str] = None,
        tags: Optional[List[str]] = None,
        sort_order: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """List tasks with filters (server streaming)"""
        # Create request
        # request = tasks_pb2.ListTasksRequest(
        #     page_size=page_size,
        #     page_token=page_token or "",
        #     assigned_to=assigned_to or ""
        # )
        
        # Handle streaming response
        tasks = []
        # async for task in self.stub.ListTasks(request):
        #     tasks.append(self._task_to_dict(task))
        
        return tasks
    
    async def get_task(self, task_id: str) -> Dict[str, Any]:
        """Get a single task by ID"""
        # request = tasks_pb2.GetTaskRequest(id=task_id)
        
        try:
            # response = await self.stub.GetTask(request)
            # return self._task_to_dict(response)
            pass
        except grpc.RpcError as e:
            if e.code() == grpc.StatusCode.NOT_FOUND:
                raise TaskNotFoundError(f"Task with ID {task_id} not found")
            raise
    
    async def create_task(
        self,
        title: str,
        description: Optional[str] = None,
        priority: Optional[str] = None,
        tags: Optional[List[str]] = None,
        assigned_to: Optional[str] = None,
        due_date: Optional[str] = None
    ) -> Dict[str, Any]:
        """Create a new task"""
        # task = tasks_pb2.Task(
        #     title=title,
        #     description=description or "",
        #     tags=tags or []
        # )
        
        # Set optional fields
        # if priority:
        #     task.priority = self._string_to_priority(priority)
        # if assigned_to:
        #     task.assigned_to = assigned_to
        
        # request = tasks_pb2.CreateTaskRequest(task=task)
        
        try:
            # response = await self.stub.CreateTask(request)
            # return self._task_to_dict(response)
            pass
        except grpc.RpcError as e:
            if e.code() == grpc.StatusCode.INVALID_ARGUMENT:
                raise ValidationError(e.details())
            raise
    
    async def update_task(
        self,
        task_id: str,
        title: Optional[str] = None,
        description: Optional[str] = None,
        status: Optional[str] = None,
        priority: Optional[str] = None,
        tags: Optional[List[str]] = None,
        assigned_to: Optional[str] = None,
        due_date: Optional[str] = None
    ) -> Dict[str, Any]:
        """Update an existing task"""
        # task = tasks_pb2.Task(id=task_id)
        update_mask = []
        
        # Set fields to update
        # if title is not None:
        #     task.title = title
        #     update_mask.append("title")
        
        # request = tasks_pb2.UpdateTaskRequest(
        #     task=task,
        #     update_mask=update_mask
        # )
        
        try:
            # response = await self.stub.UpdateTask(request)
            # return self._task_to_dict(response)
            pass
        except grpc.RpcError as e:
            if e.code() == grpc.StatusCode.NOT_FOUND:
                raise TaskNotFoundError(f"Task with ID {task_id} not found")
            elif e.code() == grpc.StatusCode.INVALID_ARGUMENT:
                raise ValidationError(e.details())
            raise
    
    async def delete_task(self, task_id: str) -> bool:
        """Delete a task"""
        # request = tasks_pb2.DeleteTaskRequest(id=task_id)
        
        try:
            # await self.stub.DeleteTask(request)
            return True
        except grpc.RpcError as e:
            if e.code() == grpc.StatusCode.NOT_FOUND:
                raise TaskNotFoundError(f"Task with ID {task_id} not found")
            raise
    
    async def watch_tasks(
        self,
        task_ids: Optional[List[str]] = None,
        watch_all: bool = False,
        assigned_to: Optional[str] = None
    ):
        """Watch for task changes (bidirectional streaming)"""
        async def request_generator():
            # Generate watch requests
            # request = tasks_pb2.WatchTasksRequest(
            #     watch_all=watch_all,
            #     task_ids=task_ids or [],
            #     assigned_to=assigned_to or ""
            # )
            # yield request
            pass
        
        try:
            # async for event in self.stub.WatchTasks(request_generator()):
            #     yield self._event_to_dict(event)
            pass
        except grpc.RpcError as e:
            print(f"Watch error: {e.details()}")
            raise
    
    def _task_to_dict(self, task) -> Dict[str, Any]:
        """Convert proto Task to dictionary"""
        # This will be implemented after proto generation
        return {}
    
    def _event_to_dict(self, event) -> Dict[str, Any]:
        """Convert proto TaskEvent to dictionary"""
        # This will be implemented after proto generation
        return {}
    
    def _string_to_priority(self, priority: str) -> int:
        """Convert string priority to proto enum value"""
        # This will be implemented after proto generation
        return 0
    
    def _string_to_status(self, status: str) -> int:
        """Convert string status to proto enum value"""
        # This will be implemented after proto generation
        return 0


class TaskGrpcError(Exception):
    """Base exception for gRPC errors"""
    pass


class TaskNotFoundError(TaskGrpcError):
    """Task not found error"""
    pass


class ValidationError(TaskGrpcError):
    """Validation error"""
    pass


async def main():
    """Example usage of the gRPC client"""
    async with TaskGrpcClient() as client:
        try:
            print("Note: This is a template. Run generate_proto.sh first to generate proto files.")
            
            # Example usage (will work after proto generation):
            
            # Create a task
            # task = await client.create_task(
            #     title="Test Python gRPC Client",
            #     description="Testing the Python gRPC client",
            #     priority="high",
            #     tags=["test", "python", "grpc"]
            # )
            # print(f"Created task: {task['id']}")
            
            # List tasks
            # tasks = await client.list_tasks(page_size=10)
            # for task in tasks:
            #     print(f"[{task['status']}] {task['title']}")
            
            # Watch for changes
            # async for event in client.watch_tasks(watch_all=True):
            #     print(f"Event: {event['event_type']} - Task: {event['task']['title']}")
            
        except TaskGrpcError as e:
            print(f"gRPC Error: {e}")
        except Exception as e:
            print(f"Unexpected error: {e}")


if __name__ == "__main__":
    asyncio.run(main())