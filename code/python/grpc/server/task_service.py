import asyncio
from concurrent import futures
from datetime import datetime
from typing import Dict, List, Optional
import uuid
import grpc
from google.protobuf import timestamp_pb2, empty_pb2

# Import generated proto files (these will be generated by the script)
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# These imports assume proto files have been generated
# import tasks_pb2
# import tasks_pb2_grpc


class TaskServicer:
    """gRPC service implementation for Task Management"""
    
    def __init__(self):
        self.tasks: Dict[str, any] = {}  # Will store Task proto objects
        self._initialize_sample_data()
    
    def _initialize_sample_data(self):
        """Initialize with sample tasks"""
        # This will be populated with proto Task objects after generation
        pass
    
    def ListTasks(self, request, context):
        """Server streaming: list tasks with filters"""
        # Filter tasks based on request parameters
        filtered_tasks = self._filter_tasks(request)
        
        # Sort tasks
        sorted_tasks = self._sort_tasks(filtered_tasks, request.sort_order)
        
        # Apply pagination
        page_size = request.page_size if request.page_size > 0 else 20
        page_size = min(page_size, 100)
        
        start_index = 0
        if request.page_token:
            try:
                start_index = int(request.page_token)
            except ValueError:
                start_index = 0
        
        # Stream tasks
        for task in sorted_tasks[start_index:start_index + page_size]:
            yield task
    
    def GetTask(self, request, context):
        """Unary: get a single task"""
        task = self.tasks.get(request.id)
        
        if not task:
            context.set_code(grpc.StatusCode.NOT_FOUND)
            context.set_details(f"Task with ID {request.id} not found")
            return None
        
        return task
    
    def CreateTask(self, request, context):
        """Unary: create a new task"""
        task = request.task
        
        if not task:
            context.set_code(grpc.StatusCode.INVALID_ARGUMENT)
            context.set_details("Task data is required")
            return None
        
        # Generate ID and set timestamps
        task.id = str(uuid.uuid4())
        
        now = timestamp_pb2.Timestamp()
        now.GetCurrentTime()
        task.created_at.CopyFrom(now)
        task.updated_at.CopyFrom(now)
        
        # Set defaults
        if not task.created_by:
            task.created_by = "system"
        
        # Validate
        if not task.title:
            context.set_code(grpc.StatusCode.INVALID_ARGUMENT)
            context.set_details("Title is required")
            return None
        
        if len(task.title) > 200:
            context.set_code(grpc.StatusCode.INVALID_ARGUMENT)
            context.set_details("Title must be 200 characters or less")
            return None
        
        self.tasks[task.id] = task
        return task
    
    def UpdateTask(self, request, context):
        """Unary: update an existing task"""
        task_id = request.task.id
        
        if not task_id:
            context.set_code(grpc.StatusCode.INVALID_ARGUMENT)
            context.set_details("Task ID is required")
            return None
        
        existing_task = self.tasks.get(task_id)
        
        if not existing_task:
            context.set_code(grpc.StatusCode.NOT_FOUND)
            context.set_details(f"Task with ID {task_id} not found")
            return None
        
        # Apply updates based on update_mask
        if request.update_mask:
            for field in request.update_mask:
                if field == 'title':
                    existing_task.title = request.task.title
                elif field == 'description':
                    existing_task.description = request.task.description
                elif field == 'status':
                    existing_task.status = request.task.status
                elif field == 'priority':
                    existing_task.priority = request.task.priority
                elif field == 'tags':
                    existing_task.tags[:] = request.task.tags
                elif field == 'assigned_to':
                    existing_task.assigned_to = request.task.assigned_to
                elif field == 'due_date':
                    existing_task.due_date.CopyFrom(request.task.due_date)
        else:
            # Update all fields if no mask provided
            self.tasks[task_id] = request.task
            existing_task = request.task
        
        # Update timestamp
        now = timestamp_pb2.Timestamp()
        now.GetCurrentTime()
        existing_task.updated_at.CopyFrom(now)
        
        return existing_task
    
    def DeleteTask(self, request, context):
        """Unary: delete a task"""
        if request.id not in self.tasks:
            context.set_code(grpc.StatusCode.NOT_FOUND)
            context.set_details(f"Task with ID {request.id} not found")
        else:
            del self.tasks[request.id]
        
        return empty_pb2.Empty()
    
    def WatchTasks(self, request_iterator, context):
        """Bidirectional streaming: watch for task changes"""
        # Simple implementation: yield events for requested tasks
        for request in request_iterator:
            if request.watch_all:
                # Return all tasks as events
                for task in self.tasks.values():
                    event = self._create_task_event(task, "UPDATED")
                    yield event
            elif request.task_ids:
                # Return specific tasks
                for task_id in request.task_ids:
                    if task_id in self.tasks:
                        event = self._create_task_event(self.tasks[task_id], "UPDATED")
                        yield event
            elif request.assigned_to:
                # Return tasks assigned to specific user
                for task in self.tasks.values():
                    if task.assigned_to == request.assigned_to:
                        event = self._create_task_event(task, "UPDATED")
                        yield event
    
    def _filter_tasks(self, request):
        """Filter tasks based on request parameters"""
        tasks = list(self.tasks.values())
        
        # Filter by status
        if request.status and request.status != 0:  # 0 is UNSPECIFIED
            tasks = [t for t in tasks if t.status == request.status]
        
        # Filter by assigned_to
        if request.assigned_to:
            tasks = [t for t in tasks if t.assigned_to == request.assigned_to]
        
        # Filter by tags
        if request.tags:
            required_tags = set(request.tags)
            tasks = [t for t in tasks if required_tags.issubset(set(t.tags))]
        
        return tasks
    
    def _sort_tasks(self, tasks, sort_order):
        """Sort tasks based on the specified order"""
        if not sort_order or sort_order == 0:  # 0 is UNSPECIFIED
            return tasks
        
        # Implement sorting based on sort_order enum
        # This will be completed after proto generation
        return tasks
    
    def _create_task_event(self, task, event_type):
        """Create a task event for streaming"""
        # This will create a TaskEvent proto object
        # Implementation will be completed after proto generation
        pass


async def serve():
    """Start the gRPC server"""
    server = grpc.aio.server()
    
    # Add service to server (after proto generation)
    # tasks_pb2_grpc.add_TaskServiceServicer_to_server(TaskServicer(), server)
    
    server.add_insecure_port('[::]:50051')
    
    print("Python gRPC server starting on port 50051...")
    await server.start()
    await server.wait_for_termination()


if __name__ == '__main__':
    asyncio.run(serve())